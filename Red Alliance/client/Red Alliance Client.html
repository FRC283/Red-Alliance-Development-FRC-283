<html>
	<head>
		<title>CLIENT - RED ALLIANCE</title>
		<link rel="stylesheet" type="text/css" href="../css/client_style.css">
	</head>
	<body>
		<header>
			<div id="logo">FRC Team 283 - RED ALLIANCE</div>
		</header>
	</body>
	<script>
		//---TODO---
		//*Data validation function
		//Mobile formatting
		//Making hotkeys swap to correct tab - stop using accesskey
		//Make sure that collected data gets put on the correct copy of the config
		//Eliminate categorical checkboxes, make it so only True/False checkboxes are a thing.
		//Checkboxes/radio should have the ability to have a text input field associated with it for additional comments - in case the scenario isnt listed

		//---FUNCTION DEFINITIONS---

		//This functions reads inputs from the given tab, and stores the data in the json file
		function writeData(tabName)
		{
			console.log("Collecting data with an id including " + tabName);									//TEMP
			for (var j = 0; j < inputList.length; j++) 		   			//Iterate through accumulated list of json inputs
			{
				for (var n = 0; n < fieldsetList.length; n++)  			//Iterate through list of accumulated html fieldsets
				{
					if (inputList[j].id == fieldsetList[n].id)    		//When the ID of a fieldset and input match
					{
						if (inputList[j].id.includes(tabName) == true)	//this input is part of the tab we're aggregating from. Note: We could also check the fieldset ID instead of the json input ID
						{
							console.log("	Collecting the data from " + fieldsetList[n].id);  				//Print the name of the question being collected
							console.log("		Function String: " + String(fieldsetList[n].collect));		//Print the contents of the collection function
							var data = fieldsetList[n].collect();		 	 								//Collect all the data in this fieldset as a string															//TEMP
							console.log("		Returned value: " + data);									//Print the value returned by the collection function
							inputList[j].value = data;		 												//Store the filled-out value of the fieldset in the json input
						}
						else																				//For any inputs not in this section
						{
							inputList[j].value = null;														//Set the value to null
						}
					}
				}
			}
		}

		//Inserts the json input object (input) as html as a child to (htmlParent)
		function renderInput(htmlParent, input)
		{
			//NOTE: All html objects are CAPITAL in comments, all json data is normal case

			//Explanation:
				//Each input is described by a json object (input)
				//Each json input is translated into a series of html objects which are then rendered
				//Each input is translated into a: <label> </label> <fieldset> <inputs...> </fieldset> <span>"hotkey"</span> (at the minimum)
			//-----------------------------------------------------------------ALL INPUT TYPES
			input.parents = htmlParent.id;						  //Each json object gets a string list of its parents
			var labelObj = document.createElement("label"); 	  //The LABEL is what actually names each input field
			labelObj.innerHTML = input.name + ":"; 				  //Set LABEL name to be based on the provided json name
			htmlParent.appendChild(labelObj); 					  //Add LABEL to given parent
			var fieldsetObj = document.createElement("fieldset"); //This FIELDSET contains all the parts of the html INPUTS associated with this json input
			htmlParent.appendChild(fieldsetObj); 				  //Add FIELDSET to PARENT
			fieldsetObj.id = htmlParent.id + "." + input.name;	  //The FIELDSET becomes named based on parent
			input.id = fieldsetObj.id;							  //Allows the json input to be easily correlated to it's FIELDSET counterpart by the json .id attribute
			
			switch (input.type)
			{
				case "number":	//---------------------------------------------------------NUMBER TYPE
					var inputObj = document.createElement("input"); 			//Creating a new INPUT html object
					fieldsetObj.appendChild(inputObj); 							//Add this number INPUT to the PARENT
					inputObj.className = "form";								//Configures CSS to display this input correctly.
					fieldsetObj.collect = function() 							//Defines the data collection function for number
					{
						return this.children[0].value; 							//Returns the sole input. Number FIELDSETS have only one INPUT, a number INPUT
					};
					fieldsetObj.hotSelect = function()							//Calls when the respective hotkey is pushed
					{
						
					};
					inputObj.min = input.details.min; 							//Create a minimum value property based on the json data
					inputObj.max = input.details.max; 							//Create a maximum value property based on the json data
					inputObj.step = input.details.step; 						//Create a step property based on the json data
					inputObj.value = input.value; 								//Create a starting value property based on the json data
					if (input.details.slider == true) 							//If the number INPUT is supposed to be a slider:
					{
						inputObj.type = "range"; 							 //Change the INPUT type to range
						var sliderValueObj = document.createElement("span"); //This new SPAN object will display the current value of the slider in it
						fieldsetObj.appendChild(sliderValueObj); 			 //Add the new SPAN to the PARENT
						sliderValueObj.innerHTML = input.value; 			 //The initial SPAN interior number is the json input default value
						inputObj.oninput = function() 						 //Whenever the INPUT slider changes, updated the SPAN that shows the value
						{
							this.nextElementSibling.innerHTML = this.value;  //The value of the SPAN text becomes equal to the value of the SLIDER whenever the SLIDER becomes updated
						}
					}
					else							//If the number INPUT is not slated to be a slider:
					{
						inputObj.type = "number";	//Explicitly defined the INPUT type as number
					}
					if (input.hotkey != null && input.hotkey != "")		//Now, regardless of the number INPUT type, a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span");  //The new SPAN object contains the hotkey assigned to this INPUT
						fieldsetObj.appendChild(hotkeyObj);				 //Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					 //Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				 //Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "text": //--------------------------------------------------------TEXT TYPE
					fieldsetObj.collect = function()	 //Defines the data collection function for text
					{
						return this.children[0].value;   //Returns the sole input. Text FIELDSETS have only one INPUT, a text INPUT
					};
					fieldsetObj.hotSelect = function()							//Calls when the respective hotkey is pushed
					{
						
					};
					if (input.details.paragraph != true) //If the input was defined as a paragraph, the text INPUT is made very large (i.e. textarea type)
					{
						var inputObj = document.createElement("input");    //Create the input as a text INPUT if not a paragraph
						inputObj.type = "text";							   //If non-paragraph, type must be explicitly defined
						inputObj.value = input.value; 					   //Assign default value to INPUT/TEXTAREA
						inputObj.placeholder = input.value; 			   //Assign default placeholder to INPUT/TEXTAREA
					}
					else												   //If it IS a paragraph type
					{
						var inputObj = document.createElement("textarea"); //Create the input as a TEXTAREA if it is a paragraph
						inputObj.value = input.value; 					   //Assign default value to INPUT/TEXTAREA
						inputObj.placeholder = input.value; 			   //Assign default placeholder to INPUT/TEXTAREA
					}
					fieldsetObj.appendChild(inputObj); 					   //Add the INPUT/TEXTAREA to the FIELDSET
					inputObj.className = "form";						   //Configures CSS to display this input correctly.
					if (input.hotkey != null && input.hotkey != "")							   //Now, regardless of being an INPUT or TEXTAREA, a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); //The new SPAN object contains the hotkey assigned to this INPUT/TEXTAREA
						fieldsetObj.appendChild(hotkeyObj);				//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				//Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "checkbox": //---------------------------------------------------------------------------CHECKBOX TYPE
					fieldsetObj.collect = function()									   //Defines the data collection function for a checkbox
					{
						//---															   //A checkbox's (json) FIELDSET contains multiple checkbox INPUTS
						var collectedValue = ""; 										   //This string will accumulate the names of all the checked INPUTS
						for (var i = 0; i < this.children.length; i++)  				   //Iterate through the FIELDSET children (a series of INPUTS)**
						{																   //**Since the length is one indexed while the array is zero indexed THE VARIABLE IS COMPARED TO LESS THAN, NOT EQUAL TO**
							if(this.children[i].type == "checkbox") 					   //Not every element in this FIELDSET is an INPUT. We much make sure we are only examining elements that area checkbox INPUTS
							{
								if(this.children[i].checked)		 					   //Check if the checkbox INPUT is checked
								{
									collectedValue = collectedValue + this.children[i].value + ", "; //If it is, add its value (not what is on the label, check code) to the accumulated value
								}
								else
								{
									collectedValue = collectedValue + "~, ";							//Placeholder character for false checkboxes. Keep this until more permanent solution
								}
							}
						}
						return collectedValue.substring(0, collectedValue.length - 2); 	   //Eliminates the ", " from the very end of the accumulation variable
					};
					fieldsetObj.hotSelect = function()									   //Calls when the respective hotkey is pushed
					{
						
					};
					for (var h = 0; h < input.details.options.length; h++)			//A checkbox FIELDSET is composed of multiple checkbox-type INPUTS**
					{																//**Since the length is one indexed while the array is zero indexed THE VARIABLE IS COMPARED TO LESS THAN, NOT EQUAL TO**
						//---														//For each checkbox defined in the details.options array:
						var tempInputObj = document.createElement("input"); 		//Create new INPUT
						fieldsetObj.appendChild(tempInputObj); 						//Add INPUT to the FIELDSET
						tempInputObj.type = "checkbox"; 							//Make the INPUT type checkbox
						tempInputObj.className = "form";						   	//Configures CSS to display this input correctly.
						if (input.details.options[h] != "") 						//If the json options for this INPUT is NOT blank:
						{
							tempInputObj.value = input.details.options[h]; 			//The INPUT name/value is supposed to be the checkbox json name
						}
						else														//If the json options for this INPUT is blank:
						{
							tempInputObj.value = "Yes";		 						//The name of the json input is the name of this html INPUT
						}
						if (input.value == "") 										//Should this checkbox INPUT be rendered as checked?
						{
							tempInputObj.checked = false; 							//If the given json input value is empty, it is unchecked
						}
						else 														//If the given json input value is NOT empty:
						{
							//The checkbox INPUT becomes checked only if the json input value contains the options value currently being rendered
							tempInputObj.checked = input.value.includes(input.details.options[h]);
							//E.G.:
								//"value":"Blue"
								//"options":["Red","Yellow","Blue"]
								//If we are rendering "Blue", then "Blue" is checked because "Blue" is a substring of the json "value"
						}
						var tempSpanObj = document.createElement("span");			//Create a SPAN element to contain labels for each checkbox
						fieldsetObj.appendChild(tempSpanObj);						//Add the SPAN to the FIELDSET
						tempSpanObj.innerHTML = input.details.options[h]; 			//The content of the SPAN is the current index-value of the options array
					}
					if (input.hotkey != null && input.hotkey != "")							//Now a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); //The new SPAN object contains the hotkey assigned to this set of INPUTS
						fieldsetObj.appendChild(hotkeyObj);				//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				//Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "radio": //---------------------------------------------------------------------------RADIO TYPE
					fieldsetObj.collect = function()									   		//Defines the data collection function for a radio. Very similar to checkbox's
					{
						//---															   		//A radio's (json) FIELDSET contains multiple checkbox INPUTS
						var collectedValue = ""; 										   		//This string will accumulate the names of all the checked INPUTS
						for (var i = 0; i < this.children.length; i++)  				   		//Iterate through the FIELDSET children (a series of INPUTS)**
						{																   		//**Since the length is one indexed while the array is zero indexed THE VARIABLE IS COMPARED TO LESS THAN, NOT EQUAL TO**
							if(this.children[i].type == "radio") 					   	   		//Not every element in this FIELDSET is an INPUT. We much make sure we are only examining elements that area radio INPUTS
							{
								if(this.children[i].checked == true) 					   		//Check if the radio INPUT is checked
								{
									collectedValue = collectedValue + this.children[i].value + ", "; //If it is, add its value (name) to the accumulated value
								}
							}
						}
						return collectedValue.substring(0, collectedValue.length - 2); 	   		//Eliminates the ", " from the very end of the accumulation variable
					};
					fieldsetObj.hotSelect = function()											//Calls when the respective hotkey is pushed
					{
						
					};
					for (var h = 0; h < input.details.options.length; h++)		//A radio FIELDSET is composed of multiple checkbox-type INPUTS**
					{															//**Since the length is one indexed while the array is zero indexed THE VARIABLE IS COMPARED TO LESS THAN, NOT EQUAL TO**
						var tempInputObj = document.createElement("input"); 	//Create INPUT element
						fieldsetObj.appendChild(tempInputObj); 					//Add INPUT to FIELDSET
						tempInputObj.value = input.details.options[h];			//Name the value of the radio to be one of the options
						tempInputObj.type = "radio"; 							//Set INPUT to type radio
						tempInputObj.name = input.name; 						//All radio INPUTS in this FIELDSET must have the same name to work properly
						tempInputObj.className = "form";						//Configures CSS to display this input correctly
						if (input.value == "") 									//If no default value is given:
						{
							tempInputObj.checked = false;  						//Then this radio INPUT is unchecked
						}
						else
						{
							tempInputObj.checked = input.value.includes(input.details.options[h]); 	//Else check through each of the input options and see if it matches the selected default input value
						}
						var tempSpanObj = document.createElement("span");		//Create a SPAN to label this checkbox INPUT
						fieldsetObj.appendChild(tempSpanObj);					//Add that SPAN to the fieldset
						tempSpanObj.innerHTML = input.details.options[h];		//Set the SPAN to contain the proper label for this INPUT
					}
					if (input.hotkey != null && input.hotkey != "")		//Now a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); //The new SPAN object contains the hotkey assigned to this set of INPUTS
						fieldsetObj.appendChild(hotkeyObj);				//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				//Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "file": //-----------------------------------------------FILE TYPE
					var inputObj = document.createElement("input");		//Create INPUT object
					fieldsetObj.append(inputObj);						//Add INPUT object to FIELDSET
					inputObj.type = "file";								//Set INPUT type to file
					inputObj.name = input.name;							//Set INPUT name to the json input
					fieldsetObj.collect = function()					//Defines data collection function for a file
					{
						var fr = new FileReader();						//Used to convert the submitted image into text
						var result;										//Will be assigned to the result of conversion to text
						var isLoaded = false;							//This variable becomes true when our dreams do
						fr.onload = function()							//This function will execute once the image has successfully been converted
						{
							result = fr.result;							//Assign the successful reading to the return value
							console.log(result);						//Return read value
						}
						if (this.children[0].value != null) 			//If a file was actually submitted:
						{
							fr.readAsDataURL(this.children[0].files[0]);//Read that file as a image
						}
						else
						{
							result = "No Image";						//Otherwise, simply put 'no image' where the image string would go
						}
						return result; 									//Then, return the image
					};
					fieldsetObj.hotSelect = function()					//Calls when the respective hotkey is pushed
					{
						
					};
				break;
			}
			//----------------------------ALL INPUT TYPES (AGAIN)
			fieldsetList.push(fieldsetObj); 									   //Append the FIELDSET onto a cumulative list
			inputList.push(input); 												   //Append the json input onto a cumulative list
		}

		//This function breaks down the input json file into smaller levels until it identifies the inputs. It renders each level as it goes. This is where the program really begins
		function renderLevel(htmlParent, level)
		{
			//----------------------------------------------------------------------
			var buttonContainerObj = document.createElement("div");		//Create a div that contains the tab buttons for this level
			htmlParent.appendChild(buttonContainerObj);					//Append to parent
			buttonContainerObj.className = "tabContainer";				//CSS
			for (var i = 0; i < level.length; i++) 						//For each element in the initial json array**
			{															//**Since the length is one indexed while the array is zero indexed THE VARIABLE IS COMPARED TO LESS THAN, NOT EQUAL TO**
				console.log("Creating object for: " + level[i].name)
				//----------------------------------------------------------------TAB BUTTON
				tabButtonObj = document.createElement("button");		//BUTTON that switches to this tab
				buttonContainerObj.appendChild(tabButtonObj);			//Attach this BUTTON to it's parent
				tabButtonObj.id = htmlParent.id + "." + level[i].name + ".Button";
				tabButtonObj.classList.add("tablinks");					//Styling for tab selection BUTTONS
				tabButtonObj.innerHTML = level[i].name + " Form";		//BUTTON text is the tab name
				tabButtonObj.onclick = function()						//When you click on a tab's selection button
				{
					var siblingTabs = this.parentNode.parentNode.children;
					for (var g = 0; g < siblingTabs.length; g++)													 //For each element on this level (sibling)
					{
						if (siblingTabs[g].nodeName.toLowerCase() == "div" && siblingTabs[g].classList.contains("tabContent")) //If that element is a DIV and classContent (not a button container)
						{
							if (siblingTabs[g].id == this.id.replace(/.Button/, ""))	//For every fellow DIV on this level... (but not the current element) - works by taking the button ID and chopping the ".Button" part off to find it's respective tab
							{
								siblingTabs[g].style.display = "block";					//Show DIV
								siblingTabs[g].classList.add("tab-selected");			//
							}
							else
							{
								siblingTabs[g].style.display = "none";					//Hide that DIV
								siblingTabs[g].classList.remove("tab-selected");		//
							}
						}
					}
					for (var k = 0; k < this.parentNode.children.length; k++) 			//Iterates through fellow tab buttons
					{
						this.parentNode.children[k].classList.remove("tab-selected");	//Remove tab-selected from all fellow buttons
					}
					this.classList.add("tab-selected"); 								//Add tab-selected back to the clicked button
				}
				//----------------------------------------------------------------------TAB DIV CREATION
				var currentObj = document.createElement("div");			//Create a DIV
				htmlParent.appendChild(currentObj);						//Attach this DIV to either a parent DIV or the top-level document
				currentObj.classList.add("tabContent");					//Make this division look like a tab
				if (i == 0) 											//If this is the first tab in this level
				{
					currentObj.style.display = "block";					//Make it visible
					tabButtonObj.classList.add("tab-selected");				//Styling for tab selection BUTTONS
				}	
				else													//Otherwise
				{
					currentObj.style.display = "none";					//Hide it
				}
				currentObj.id = htmlParent.id + "." + level[i].name;	//Assign an id to the DIV based on its PARENT name as well
				level[i].id = currentObj.id;							//Save the id of this div to the json
				if (level[i].terminal == false) 						//If this json level is not marked as "terminal"
				{
					console.log("-" + level[i].name + " is not terminating.");
					renderLevel(currentObj, level[i].tabs); 			//Recursively call this function to process the next array level
				}
				else 													//If this json level is terminal, it is an "input"
				{
					console.log("-" + level[i].name + " is terminating.");
					for (var j = 0; j < level[i].inputs.length; j++)	//For each "input" in this level
					{
						renderInput(currentObj, level[i].inputs[j]);	//Call render input, which will append "html input elements" (sorta) onto the "currentObj" element
					}
				}
				//---------------------------------------------------------------------------BUTTON CREATION
				if (level[i].submittable == true) 						//After rendering all subinputs, create a button if this level is submittable.
				{
					//---												//When the button is pressed, the data from all the subelements with be collected
					var buttonObj = document.createElement("button");	//Create BUTTON html object
					currentObj.appendChild(buttonObj);					//Add the BUTTON as a subelement of whatever DIV we currently edit
					buttonObj.innerHTML = "Submit " + level[i].name;	//Give the BUTTON a name based on json
					buttonObj.className = "form-submit";				//Mark the BUTTON for proper css
					buttonObj.onclick = function()						//Executes on click
					{
						var parentName = this.parentElement.id.slice(this.parentElement.id.lastIndexOf("."), this.parentElement.id.length); //The directly-parent level name. See below for explanation
						//parentElement.id = ".Match.Main" (as example)
						//.lastIndexOf - grabs the index of the last occurence of "." = 13
						//.length = 17
						//.slice(13, 17) = "Main"
						//"Main" is the id of the element that DIRECTLY contains this one
						console.log("Button pressed! Containing element is " + parentName);														//TEMP
						writeData(parentName); 																							  		//On click, gather all data inside this section
						console.log("Current state of the json inputs: " + JSON.stringify(inputList)); 										    //TEMP
					}
				}
			}
		}
		
		//Converts a given number to it's ASCII letter
		function toASCII(number)
		{
			switch (number)
			{
				case 192:
					return "`";
				break;
				case 16:
					return "SHIFT"
				break;
				case 189:
					return "-";
				break;
				case 187:
					return "+";
				break;
				case 18:
					return "[";
				case 17:
					return "CONTROL"
				break;
				case 186:
					return ";";
				break;
				case 222:
					return "\"";
				break;
				case 188:
					return ",";
				break;
				case 190:
					return ".";
				break;
				case 191:
					return "/";
				break;
				case 220:
					return "\\";
				break;
				default:
					return String.fromCharCode(number);					    				//Returns ascii character	
				break;
			}
		}
		
		//Triggers on hotkey presses. Calls the proper switch function for the press
		function hotkeyManager(e)
		{
			for (var y = 0; y < inputList.length; y++)							 			//Iterate through all json inputs
			{
				if (inputList[y].hotkey.toUpperCase() == toASCII(e.keyCode).toUpperCase())	//If the hotkey matches the pressed key
				{
					document.getElementById(inputList[y].id).hotSelect();					//Activate the function for it's corresponding fieldset that brings that fieldset into view
				}
			}
		}

		//---GLOBAL VARIABLES---
		var inputList = []; 	//Contains all inputs found within the configuration file
		var fieldsetList = [];  //Contains all the fieldsets of inputs

		var configFile =[
			{
				"name":"Match",
				"submittable":true,
				"terminal":false,
				"tabs":
				[
					{
						"name":"Main",
						"submittable":false,
						"terminal":true,
						"inputs":
						[
							{
								"name":"Match Number",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"`",
								"details":
								{
									"paragraph":false
								}
							},
							{
								"name":"Team Number",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"1",
								"details":
								{
									"min":1,
									"max":9999,
									"step":1,
									"slider":false,
									"fraction":false
								}
							},
							{
								"name":"Team Name",
								"type":"text",
								"value":"",
								"required":true,
								"hotkey":"2",
								"details":
								{
									"paragraph":false
								}
							}
						]
					},
					{
						"name":"Auto",
						"submittable":false,
						"terminal":true,
						"inputs":
						[
							{
								"name":"Crosses Baseline Successfully",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"4",
								"details":
								{
									"options":[""]
								}
							},
							{
								"name":"Cubes Put In Switch",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"5",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Cubes Put In Scale",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"Q",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Cubes Put In Vault/Exchange Zone",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"W",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Comments/Overview",
								"type":"text",
								"value":"",
								"required":true,
								"hotkey":"E",
								"details":
								{
									"paragraph":true
								}
							}
						]
					},
					{
						"name":"Teleop",
						"submittable":false,
						"terminal":true,
						"inputs":
						[
							{
								"name":"Cubes Put In Switch",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"R",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Cubes Put In Scale",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"A",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Cubes Put In Vault/Exchange Zone",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"5",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Primary Source of Cubes",
								"type":"radio",
								"value":"",
								"required":true,
								"hotkey":"D",
								"details":
								{
									"options":["Allied Platform", "Enemy Platform", "Portal", "Power Cube Zone"]
								}
							},
							{
								"name":"Attempts to Block Enemy Scoring",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"F",
								"details":
								{
									"options":[""]
								}
							},
							{
								"name":"Lifts Successfully",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"Z",
								"details":
								{
									"options":[""]
								}
							},
							{
								"name":"Another Robot Hangs Off of This One",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"X",
								"details":
								{
									"options":[""]
								}
							},
							{
								"name":"Main Strategy",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"C",
								"details":
								{
									"options":["Put Cubes on Switch", "Put Cubes on Scale", "Provide Cubes to Vault", "Lift Reliably"]
								}
							},
							{
								"name":"Comments/Overview",
								"type":"text",
								"value":"",
								"required":true,
								"hotkey":"L-Shift",
								"details":
								{
									"paragraph":true
								}
							}
						]
					}
				]
			},
			{
				"name":"Pit",
				"terminal":true,
				"submittable":true,
				"inputs":
				[
					{
						"name":"Robot Image",
						"type":"file",
						"value":"",
						"required":"false",
						"hotkey":"",
						"details":
						{
							"formats":[".png",".jpg"]
						}
					},
					{
						"name":"Team Number",
						"type":"number",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"min":1,
							"max":9999,
							"step":1,
							"slider":false,
							"fraction":false
						}
					},
					{
						"name":"Team Name",
						"type":"text",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"paragraph":false
						}
					},
					{
						"name":"Type of Motors on Drivetrain",
						"type":"text",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"paragraph":false
						}
					},
					{
						"name":"Number of Motors on Drive",
						"type":"text",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"paragraph":false
						}
					},
					{
						"name":"Drivetrain Overview/Comments",
						"type":"text",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"paragraph":false
						}
					},
					{
						"name":"Can Lift",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{
							"options":[""]
						}
					},
					{
						"name":"Lift Clearance from Ground",
						"type":"number",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"min":1,
							"max":120,
							"step":0.5,
							"slider":false,
							"fraction":false
						}
					},
					{
						"name":"Weight",
						"type":"number",
						"value":120,
						"required":true,
						"hotkey":"",
						"details":
						{
							"min":1,
							"max":120,
							"step":0.5,
							"slider":true,
							"fraction":false
						}
					},
					{
						"name":"Automatically Adjusts Side on Autonomous",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{
							"options":[""]
						}
					},
					{
						"name":"Puts Cube on Switch in Autonomous",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{
							"options":[""]
						}
					},
					{
						"name":"Puts Cube on Scale in Autonomous",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{
							"options":[""]
						}
					},
					{
						"name":"Main Strategy",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{
							"options":["Put Cubes on Switch", "Put Cubes on Scale", "Provide Cubes to Vault", "Lift Reliably"]
						}
					},
					{
						"name":"Primary Source of Cubes",
						"type":"radio",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"options":["Allied Platform", "Enemy Platform", "Portal", "Power Cube Zone"]
						}
					}
				]
			}	
		]

		//---ONLOAD FUNCTION CALLS---
		document.addEventListener("keydown", hotkeyManager, false); //Registers hotkeyManager as an event listener
		renderLevel(document.body, configFile); //Renders the configuration object above, using the document body as the parent. Kicks off the program.
	</script>
</html>
