<html>
	<head>
		<title>CLIENT - RED ALLIANCE</title>
		<link rel="stylesheet" type="text/css" href="../css/client_style.css">
	</head>
	<body>
		<header>
			<div id="logo">FRC Team 283 - RED ALLIANCE</div>
		</header>
	</body>
	<script>
		//---TODO---
		//*Allow default values for checkboxes and radios
		//*Finish collectData functions for checkbox and radio
		//*Finish writeData function by grabbing configValues by id and comparing them to fieldsets
		//*Data validation function
		//*Submission Button
		//*Tab Partitioning
			//*Tab visibility function
		//Creating a submission button
		//Making hotkeys swap to correct tab
		
		//---FUNCTION DEFINITIONS---
		
		//This functions reads the "form" we've created, and stores the values in a json file
		function writeData()
		{
			for (var j = 0; j < inputList.length; j++) 		   //Iterate through accumulated list of json inputs
			{
				for (var n = 0; n < fieldsetList.length; n++)  //Iterate through list of accumulated html fieldsets
				{
					if (inputList[j].id == fieldsetList[n] && inputList[j].type != "button")    //When the ID of a fieldset and input match
					{
						inputList[j].value = eval(fieldsetList[n].getAttribute("data-collect")); //Store the filled-out value of the fieldset in the json input
					}
				}
			}
			console.log("inputList: " + stringify(inputList));
		}
		
		//Inserts the json input object (input) as html as a child to fuck(htmlParent)
		function renderInput(htmlParent, input)
		{
			//NOTE: All html objects are CAPITAL in comments, all json data is normal case
			
			//Explanation: 
				//Each input is described by a json object (input)
				//Each json input is translated into a series of html objects which are then rendered
				//Each input is translated into a: <label> </label> <fieldset> <inputs...> </fieldset> <span>"hotkey"</span> (at the minimum)
			
			//-----------------------------------------------------------------ALL INPUT TYPES
			input.id = idIndex; 								  //Assign the current index to this input
			idIndex++; 											  //Up the index
			var labelObj = document.createElement("label"); 	  //The LABEL is what actually names each input field
			labelObj.innerHTML = input.name + ":"; 				  //Set LABEL name to be based on the provided json name
			htmlParent.appendChild(labelObj); 					  //Add LABEL to given parent
			var fieldsetObj = document.createElement("fieldset"); //This FIELDSET contains all the parts of the html INPUTS associated with this json input
			htmlParent.appendChild(fieldsetObj); 				  //Add FIELDSET to PARENT
			var dataCollectFunction; 							  //This function becomes associated with this FIELDSET, and returns the accumulated data from this FIELDSET when called
			var dataSubmissionFunction;
			switch (input.type)								  //Additional rendering depends on type of input
			{
				case "number":	//-----------------------------------------------NUMBER TYPE
					var inputObj = document.createElement("input"); //Creating a new INPUT html object
					fieldsetObj.appendChild(inputObj); 				//Add this number INPUT to the PARENT
					dataCollectFunction = function() 				//Defines the data collection function for number
					{
						return this.children[0].value; 				//Returns the sole input. Number FIELDSETS have only one INPUT, a number INPUT
					}
					inputObj.id = htmlParent.id + "." + input.name; //Create a unique id for the number INPUT
					inputObj.min = input.details.min; 				//Create a minimum value property based on the json data
					inputObj.max = input.details.max; 				//Create a maximum value property based on the json data
					inputObj.step = input.details.step; 			//Create a step property based on the json data
					inputObj.value = input.value; 					//Create a starting value property based on the json data
					if (input.details.slider == true) 				//If the number INPUT is supposed to be a slider:
					{
						inputObj.type = "range"; 							 //Change the INPUT type to range
						var sliderValueObj = document.createElement("span"); //This new SPAN object will display the current value of the slider in it
						fieldsetObj.appendChild(sliderValueObj); 			 //Add the new SPAN to the PARENT
						sliderValueObj.id = inputObj.id + ".SliderValue";	 //Give SPAN an id
						sliderValueObj.innerHTML = input.value; 			 //The initial SPAN interior number is the json input default value
						inputObj.oninput = function() 						 //Whenever the INPUT slider changes, updated the SPAN that shows the value
						{
							this.nextElementSibling.innerHTML = this.value;  //The value of the SPAN text becomes equal to the value of the SLIDER whenever the SLIDER becomes updated
						}
					}
					else							//If the number INPUT is not slated to be a slider:
					{
						inputObj.type = "number";	//Explicitly defined the INPUT type as number
					}
					if (input.hotkey != null)		//Now, regardless of the number INPUT type, a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span");  //The new SPAN object contains the hotkey assigned to this INPUT
						htmlParent.appendChild(hotkeyObj);				 //Add the new SPAN onto the PARENT
						inputObj.accesskey = input.hotkey; 				 //Create a accesskey property based on the json data. The accesskey serves as a hotkey (alt + hotkey)
						hotkeyObj.className = "hotkey";					 //Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				 //Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "text": //--------------------------------------------------------TEXT TYPE
					dataCollectFunction = function() 	 //Defines the data collection function for text
					{
						return this.children[0].value;   //Returns the sole input. Text FIELDSETS have only one INPUT, a text INPUT
					}
					if (input.details.paragraph != true) //If the input was defined as a paragraph, the text INPUT is made very large (i.e. textarea type)
					{
						var inputObj = document.createElement("input");    //Create the input as a text INPUT if not a paragraph
						inputObj.type = "text";							   //If non-paragraph, type must be explicitly defined
					}
					else												   //If it IS a paragraph type
					{
						var inputObj = document.createElement("textarea"); //Create the input as a TEXTAREA if it is a paragraph
					}
					fieldsetObj.appendChild(inputObj); 					//Add the INPUT/TEXTAREA to the FIELDSET
					inputObj.id = htmlParent.id + "." + input.name; 	//Give INPUT/TEXTAREA an id
					inputObj.value = input.value; 						//Assign default value to INPUT/TEXTAREA
					inputObj.innerHTML = input.value; 					//Assign default value to INPUT/TEXTAREA (Redundant)
					if (input.hotkey != null)							//Now, regardless of being an INPUT or TEXTAREA, a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); //The new SPAN object contains the hotkey assigned to this INPUT/TEXTAREA
						htmlParent.appendChild(hotkeyObj);				//Add the new SPAN onto the PARENT
						inputObj.accesskey = input.hotkey; 				//Create a accesskey property based on the json data. The accesskey serves as a hotkey (alt + hotkey)
						hotkeyObj.className = "hotkey";					//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				//Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "checkbox": //---------------------------------------------------------------------------CHECKBOX TYPE
					dataCollectFunction = function ()									   //Defines the data collection function for a checkbox
					{
						//---															   //A checkbox's (json) FIELDSET contains multiple checkbox INPUTS
						var collectedValue = ""; 										   //This string will accumulate the names of all the checked INPUTS
						for (var i = 0; i < this.children.length; i++)  				   //Iterate through the FIELDSET children (a series of INPUTS)
						{
							if(this.children[i].type == "checkbox") 					   //Not every element in this FIELDSET is an INPUT. We much make sure we are only examining elements that area checkbox INPUTS
							{
								if(input.children[i].checked == true) 					   //Check if the checkbox INPUT is checked
								{
									collectedValue.append(input.children[i].value + ", "); //If it is, add its value (name) to the accumulated value
								}
							}
						}
						return collectedValue.substring(0, collectedValue.length - 2); 	   //Eliminates the ", " from the very end of the accumulation variable
					}
					if (input.hotkey != null)							//Now a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); //The new SPAN object contains the hotkey assigned to this set of INPUTS
						htmlParent.appendChild(hotkeyObj);				//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				//Display the json-defined hotkey inside of this SPAN
					}
					for (var h = 0; h < input.details.options.length; h++)			//A checkbox FIELDSET is composed of multiple checkbox-type INPUTS
					{
						//---														//For each checkbox defined in the details.options array:
						var tempInputObj = document.createElement("input"); 		//Create new INPUT
						fieldsetObj.appendChild(tempInputObj); 						//Add INPUT to the FIELDSET
						tempInputObj.type = "checkbox"; 							//Make the INPUT type checkbox
						if (input.details.options[h] != "") 						//If the json options for this INPUT is NOT blank: 
						{
							tempInputObj.value = input.details.options[h]; 			//The INPUT name/value is supposed to be the checkbox json name
						}
						else														//If the json options for this INPUT is blank: 
						{
							tempInputObj.value = input.name; 						//The name of the json input is the name of this html INPUT
						}
						if (input.value == "") 										//Should this checkbox INPUT be rendered as checked?
						{
							tempInputObj.checked = false; 							//If the given json input value is empty, it is unchecked
						}
						else 														//If the given json input value is NOT empty:
						{
							//The checkbox INPUT becomes checked only if the json input value contains the options value currently being rendered
							tempInputObj.checked = input.value.includes(input.details.options[h]);
							//E.G.:
								//"value":"Blue"
								//"options":["Red","Yellow","Blue"]
								//If we are rendering "Blue", then "Blue" is checked because "Blue" is a substring of the json "value"
						}
						var tempSpanObj = document.createElement("span");			//Create a SPAN element to contain labels for each checkbox
						fieldsetObj.appendChild(tempSpanObj);						//Add the SPAN to the FIELDSET
						tempSpanObj.innerHTML = input.details.options[h]; 			//The content of the SPAN is the current index-value of the options array
						if (h = 0)													//If this is the first checkbox INPUT rendered:
						{
							tempInputObj.accesskey = input.hotkey; 					//Create a accesskey property based on the json data. The accesskey serves as a hotkey (alt + hotkey)
						}
					}
				break;
				case "radio": //---------------------------------------------------------------------------RADIO TYPE
					dataCollectFunction = function ()									   //Defines the data collection function for a radio. Very similar to checkbox's
					{
						//---															   //A radio's (json) FIELDSET contains multiple checkbox INPUTS
						var collectedValue = ""; 										   //This string will accumulate the names of all the checked INPUTS
						for (var i = 0; i < this.children.length; i++)  				   //Iterate through the FIELDSET children (a series of INPUTS)
						{
							if(this.children[i].type == "radio") 					   	   //Not every element in this FIELDSET is an INPUT. We much make sure we are only examining elements that area radio INPUTS
							{
								if(input.children[i].checked == true) 					   //Check if the radio INPUT is checked
								{
									collectedValue.append(input.children[i].value + ", "); //If it is, add its value (name) to the accumulated value
								}
							}
						}
						return collectedValue.substring(0, collectedValue.length - 2); 	   //Eliminates the ", " from the very end of the accumulation variable
					}
					if (input.hotkey != null)							//Now a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); //The new SPAN object contains the hotkey assigned to this set of INPUTS
						htmlParent.appendChild(hotkeyObj);				//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				//Display the json-defined hotkey inside of this SPAN
					}
					for (var h = 0;h < input.details.options.length; h++)		//A radio FIELDSET is composed of multiple checkbox-type INPUTS
					{
						var tempInputObj = document.createElement("input"); 	//Create INPUT element
						fieldsetObj.appendChild(tempInputObj); 					//Add INPUT to FIELDSET
						tempInputObj.type = "radio"; 							//Set INPUT to type radio
						tempInputObj.name = input.name; 						//All radio INPUTS in this FIELDSET must have the same name to work properly
						if (input.value == "") 									//If no default value is given:
						{
							tempInputObj.checked = false;  						//Then this radio INPUT is unchecked
						}
						else
						{
							tempInputObj.checked = input.value.includes(input.details.options[h]); 	//Else check through each of the input options and see if it matches the selected default input value
						}
						var tempSpanObj = document.createElement("span");		//Create a SPAN to label this checkbox INPUT
						fieldsetObj.appendChild(tempSpanObj);					//Add that SPAN to the fieldset
						tempSpanObj.innerHTML = input.details.options[h];		//Set the SPAN to contain the proper label for this INPUT
					}
				break;
				case "file": //-----------------------------------------------FILE TYPE
					var inputObj = document.createElement("input");		//Create INPUT object
					fieldsetObj.append(inputObj);						//Add INPUT object to FIELDSET
					inputObj.type = "file";								//Set INPUT type to file
					inputObj.name = input.name;							//Set INPUT name to the json input
					inputObj.id = htmlParent + "." + input.name;		//Set INPUT id
					dataCollectFunction = function ()					//Defines data collection function for a file
					{
						var fr = new FileReader();						//Used to convert the submitted image into text
						var result;										//Will be assigned to the result of conversion to text
						fr.onload = function()							//This function will execute once the image has successfully been converted
						{
							result = fr.result;							//Assign the successful reading to the return value
						}
						if (this.children[0].value != null) 			//If a file was actually submitted:
						{
							fr.readAsDataUrl(this.children[0].value);	//Read that file as a image
						}
						else
						{
							result = "No Image";						//Otherwise, simply put 'no image' where the image string would go
						}
						return result; 									//Then, return the image
					}
				break;
				case "button":
					var inputObj = document.createElement("button")
					fieldset.append(inputObj);
					inputObj.type = "button";
					inputObj.id = htmlParent + "." + input.name;
					dataSubmissionFunction = function ()
					{
						
					}
			}
			//----------------------------ALL INPUT TYPES (AGAIN)
			fieldsetObj.setAttribute("data-collect", String(dataCollectFunction)); //"Assign" the data collection function to the FIELDSET
			fieldsetList.push(fieldsetObj); 									   //Append the FIELDSET onto a cumulative list
			inputList.push(input) 												   //Append the json input onto a cumulative list
		}
		
		//This function breaks down the input json file into smaller levels until it identifies the inputs. It renders each level as it goes. This is where the program really begins
		function renderLevel(htmlParent, level)
		{
			var currentObj; 											//Current HTML DOM element being created
			for (var i = 0; i < level.length; i++) 						//For each element in the initial json array
			{
				console.log("Creating object for: " + level[i].name)
				currentObj = document.createElement("div");				//Create a DIV
				htmlParent.appendChild(currentObj);						//Attach this DIV to either a parent DIV or the top-level document
				currentObj.id = htmlParent.id + "." + level[i].name;	//Assign an id to the DIV based on its PARENT name as well
				if (level[i].terminal == false) 						//If this json level is not marked as "terminal"
				{
					console.log("-" + level[i].name + " is not terminating.");
					renderLevel(currentObj, level[i].tabs); 			//Recursively call this function to process the next array level
				}
				else 													//If this json level is terminal, it is an "input"
				{
					console.log("-" + level[i].name + " is terminating.");
					for (var j = 0; j < level[i].inputs.length; j++)	//For each "input" in this level
					{
						renderInput(currentObj, level[i].inputs[j]);	//Call render input, which will append "html input elements" (sorta) onto the "currentObj" element
					}
				}
			}
		}
		
		//---GLOBAL VARIABLES---
		var idIndex = 0;
		var inputList = []; 	//Contains all inputs found within the configuration file
		var fieldsetList = [];  //Contains all the fieldsets of inputs
		
		var configFile = [
              	{
            		"name":"Match",
            		"terminal":false,
            		"tabs":
            		[
            			{
            				"name":"Main",
            				"terminal":true,
            				"inputs":
            				[
            					{
            						"name":"Match Number",
            						"type":"text",
            						"value":"",
            						"required":true,
            						"hotkey":"~",
            						"details":
            						{
            							"paragraph":false
            						}
            					},
            					{
            						"name":"Team Number",
            						"type":"number",
            						"value":"",
            						"required":true,
            						"hotkey":"1",
            						"details":
            						{
            							"min":1,
            							"max":9999,
            							"step":1,
            							"slider":false,
            							"fraction":false
            						}
            					},
            					{
            						"name":"Team Name",
            						"type":"text",
            						"value":"",
            						"required":true,
            						"hotkey":"2",
            						"details":
            						{
            							"paragraph":false
            						}
            					}
            				]
            			},
            			{
            				"name":"Auto",
            				"terminal":true,
            				"inputs":
            				[
            					{
            						"name":"Crosses Baseline Successfully",
            						"type":"checkbox",
            						"value":"",
            						"required":false,
            						"hotkey":"4",
            						"details":
            						{
            							"options":[""]
            						}
            					},
            					{
            						"name":"Cubes Put In Switch",
            						"type":"number",
            						"value":"",
            						"required":true,
            						"hotkey":"5",
            						"details":
            						{
            							"min":0,
            							"max":999,
            							"step":1,
            							"slider":false,
            							"fraction":true
            						}
            					},
            					{
            						"name":"Cubes Put In Scale",
            						"type":"number",
            						"value":"",
            						"required":true,
            						"hotkey":"Q",
            						"details":
            						{
            							"min":0,
            							"max":999,
            							"step":1,
            							"slider":false,
            							"fraction":true
            						}
            					},
            					{
            						"name":"Cubes Put In Vault/Exchange Zone",
            						"type":"number",
            						"value":"",
            						"required":true,
            						"hotkey":"W",
            						"details":
            						{
            							"min":0,
            							"max":999,
            							"step":1,
            							"slider":false,
            							"fraction":true
            						}
            					},
            					{
            						"name":"Comments/Overview",
            						"type":"text",
            						"value":"",
            						"required":true,
            						"hotkey":"E",
            						"details":
            						{
            							"paragraph":true
            						}
            					}
            				]
            			},
            			{
            				"name":"Teleop",
            				"terminal":true,
            				"inputs":
            				[
            					{
            						"name":"Cubes Put In Switch",
            						"type":"number",
            						"value":"",
            						"required":true,
            						"hotkey":"R",
            						"details":
            						{
            							"min":0,
            							"max":999,
            							"step":1,
            							"slider":false,
            							"fraction":true
            						}
            					},
            					{
            						"name":"Cubes Put In Scale",
            						"type":"number",
            						"value":"",
            						"required":true,
            						"hotkey":"A",
            						"details":
            						{
            							"min":0,
            							"max":999,
            							"step":1,
            							"slider":false,
            							"fraction":true
            						}
            					},
            					{
            						"name":"Cubes Put In Vault/Exchange Zone",
            						"type":"number",
            						"value":"",
            						"required":true,
            						"hotkey":"5",
            						"details":
            						{
            							"min":0,
            							"max":999,
            							"step":1,
            							"slider":false,
            							"fraction":true
            						}
            					},
            					{
            						"name":"Primary Source of Cubes",
            						"type":"radio",
            						"value":"",
            						"required":true,
            						"hotkey":"D",
            						"details":
            						{
            							"options":["Allied Platform", "Enemy Platform", "Portal", "Power Cube Zone"]
            						}
            					},
            					{
            						"name":"Attempts to Block Enemy Scoring",
            						"type":"checkbox",
            						"value":"",
            						"required":false,
            						"hotkey":"F",
            						"details":
            						{
            							"options":[""]
            						}
            					},
            					{
            						"name":"Lifts Successfully",
            						"type":"checkbox",
            						"value":"",
            						"required":false,
            						"hotkey":"Z",
            						"details":
            						{
            							"options":[""]
            						}
            					},
            					{
            						"name":"Another Robot Hangs Off of This One",
            						"type":"checkbox",
            						"value":"",
            						"required":false,
            						"hotkey":"X",
            						"details":
            						{
            							"options":[""]
            						}
            					},
            					{
            						"name":"Main Strategy",
            						"type":"checkbox",
            						"value":"",
            						"required":false,
            						"hotkey":"C",
            						"details":
            						{
            							"options":["Put Cubes on Switch", "Put Cubes on Scale", "Provide Cubes to Vault", "Lift Reliably"]
            						}
            					},
            					{
            						"name":"Comments/Overview",
            						"type":"text",
            						"value":"",
            						"required":true,
            						"hotkey":"L-Shift",
            						"details":
            						{
            							"paragraph":true
            						}
            					}
            				]
            			}
            		]
            	},
            	{
            		"name":"Pit",
            		"terminal":true,
            		"inputs":
            		[
            			{
            				"name":"Robot Image",
            				"type":"file",
            				"value":"",
            				"required":"false",
            				"hotkey":null,
            				"details":
            				{
            					"formats":[".png",".jpg"]
            				}
            			},
            			{
            				"name":"Team Number",
            				"type":"number",
            				"value":"",
            				"required":true,
            				"hotkey":"null",
            				"details":
            				{
            					"min":1,
            					"max":9999,
            					"step":1,
            					"slider":false,
            					"fraction":false
            				}
            			},
            			{
            				"name":"Team Name",
            				"type":"text",
            				"value":"",
            				"required":true,
            				"hotkey":"null",
            				"details":
            				{
            					"paragraph":false
            				}
            			},
            			{
            				"name":"Type of Motors on Drivetrain",
            				"type":"text",
            				"value":"",
            				"required":true,
            				"hotkey":"null",
            				"details":
            				{
            					"paragraph":false
            				}
            			},
            			{
            				"name":"Number of Motors on Drive",
            				"type":"text",
            				"value":"",
            				"required":true,
            				"hotkey":"null",
            				"details":
            				{
            					"paragraph":false
            				}
            			},
            			{
            				"name":"Drivetrain Overview/Comments",
            				"type":"text",
            				"value":"",
            				"required":true,
            				"hotkey":"null",
            				"details":
            				{
            					"paragraph":false
            				}
            			},
            			{
            				"name":"Can Lift",
            				"type":"checkbox",
            				"value":"",
            				"required":false,
            				"hotkey":"null",
            				"details":
            				{
            					"options":[""]
            				}
            			},
            			{
            				"name":"Lift Clearance from Ground",
            				"type":"number",
            				"value":"",
            				"required":true,
            				"hotkey":"null",
            				"details":
            				{
            					"min":1,
            					"max":120,
            					"step":0.5,
            					"slider":false,
            					"fraction":false
            				}
            			},
            			{
            				"name":"Weight",
            				"type":"number",
            				"value":120,
            				"required":true,
            				"hotkey":"null",
            				"details":
            				{
            					"min":1,
            					"max":120,
            					"step":0.5,
            					"slider":true,
            					"fraction":false
            				}
            			},
            			{
            				"name":"Automatically Adjusts Side on Autonomous",
            				"type":"checkbox",
            				"value":"",
            				"required":false,
            				"hotkey":"null",
            				"details":
            				{
            					"options":[""]
            				}
            			},
            			{
            				"name":"Puts Cube on Switch in Autonomous",
            				"type":"checkbox",
            				"value":"",
            				"required":false,
            				"hotkey":"null",
            				"details":
            				{
            					"options":[""]
            				}
            			},
            			{
            				"name":"Puts Cube on Scale in Autonomous",
            				"type":"checkbox",
            				"value":"",
            				"required":false,
            				"hotkey":"null",
            				"details":
            				{
            					"options":[""]
            				}
            			},
            			{
            				"name":"Main Strategy",
            				"type":"checkbox",
            				"value":"",
            				"required":false,
            				"hotkey":"null",
            				"details":
            				{
            					"options":["Put Cubes on Switch", "Put Cubes on Scale", "Provide Cubes to Vault", "Lift Reliably"]
            				}
            			},
            			{
            				"name":"Primary Source of Cubes",
            				"type":"radio",
            				"value":"",
            				"required":true,
            				"hotkey":"null",
            				"details":
            				{
            					"options":["Allied Platform", "Enemy Platform", "Portal", "Power Cube Zone"]
            				}
            			}
            		]
            	}	
            ]
		
		//---ONLOAD FUNCTION CALLS---
		renderLevel(document.body, configFile); //Renders the configuration object above, using the document body as the parent. Kicks off the program.
	</script>
</html>