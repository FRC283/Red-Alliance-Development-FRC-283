<html>
	<head>
		<title>CLIENT - RED ALLIANCE</title>
		<link rel="stylesheet" type="text/css" href="../css/client_style.css">
	</head>
	<body>
		<header>
			<div id="logo">FRC Team 283 - RED ALLIANCE</div>
		</header>
	</body>
		<div class="information-panel">
			Italic Text = Optional Field
		</div>
	<script>
		//---TODO---
		//Put a nice outline around fieldsets
		//Method of visually grouping inputs
		//Mobile formatting
		//Make sure that collected data gets put on the correct copy of the config
		//Make fractions work
		//Error message rendering
		//Weight slider being weird (Changed steps of 1 to fix issue)
		//plz comment renderError
		//Hotkey toggle checkbox
		//Multiple inputs use H
		//Make comments not required
		
		//NOTE NOTE NOTE: BE VERY CAREFUL CHANGING THE RENDERING FUNCTIONS. MANY READING FUNCTIONS MAKE ASSUMPTIONS ABOUT THE STRUCTURES OF THE ELEMENTS THEY READ AND WILL NEED CHANGES AS WELL.
		
		//---FUNCTION DEFINITIONS---

		//Inserts an error message above the given fieldset if the "goodData" parameter is true. Hides it if "goodData" if false
		function renderError(fieldsetObj, goodData)
		{
			if (goodData == false)
			{
				console.log("	Rendering the error for " + fieldsetObj.id);
				fieldsetObj.hotSelect();
				if (document.getElementById(fieldsetObj.id + ".ValidationError!") == null)
				{
					var errorObj = document.createElement("div");
					errorObj.className = "error";
					errorObj.id = fieldsetObj.id + ".ValidationError!"
					errorObj.innerHTML = "Please fill out this input correctly.";
					fieldsetObj.parentElement.insertBefore(errorObj, fieldsetObj);		
				}
			}
			else
			{
				console.log("	Removing the error for " + fieldsetObj.id);
				while (document.getElementById(fieldsetObj.id + ".ValidationError!") != null)
				{
					console.log("Removing Error Message for: " + fieldsetObj.parentElement.removeChild(document.getElementById(fieldsetObj.id + ".ValidationError!")));
				}
			}
		}
		
		//This functions reads inputs from the given tab, and stores the data in the json file
		function writeData(tabName)
		{
			var dataSubmitted = true;
			console.log("Collecting data with an id including " + tabName);
			for (var j = 0; j < inputList.length; j++) 		   			//Iterate through accumulated list of json inputs
			{
				for (var n = 0; n < fieldsetList.length; n++)  			//Iterate through list of accumulated html fieldsets
				{
					if (inputList[j].id == fieldsetList[n].id)    		//When the ID of a fieldset and input match
					{
						if (inputList[j].id.includes(tabName) == true)	//this input is part of the tab we're aggregating from. Note: We could also check the fieldset ID instead of the json input ID
						{
							console.log("	Collecting the data from " + fieldsetList[n].id);  				//Print the name of the question being collected
							console.log("   Validating the data...");										//Print the contents of the collection function
							renderError(fieldsetList[n], fieldsetList[n].check());							//Add/Remove all error messages based on the validation function
							if (fieldsetList[n].check() == true)											//If the data is good
							{
								var data = fieldsetList[n].collect();		 	 							//Collect all the data in this fieldset as a string															//TEMP
								console.log("		Returned value: " + data);								//Print the value returned by the collection function
								inputList[j].value = data;		 											//Store the filled-out value of the fieldset in the json input
							}
							else
							{
								console.log("	The data was not ready. See error message.");				//Alert the dev that the form isnt filled out right
								j = inputList.length;														//Breaks the loop, killing the function
								n = inputList.length;														//Breaks the loop, killing the function
								dataSubmitted = false;
							}
						}
						else																				//For any inputs not in this section
						{
							inputList[j].value = null;														//Set the value to null if the data is not part of the section of the form being submitted
						}
					}
				}
			}
			if(dataSubmitted == true)
			{
				location.reload();
			}
		}
		
		//Inserts the json input object (input) as html as a child to (htmlParent)
		function renderInput(htmlParent, input)
		{
			//NOTE: All html objects are CAPITAL in comments, all json data is normal case

			//Explanation:
				//Each input is described by a json object (input)
				//Each json input is translated into a series of html objects which are then rendered
				//Each input is translated into a: <label> </label> <fieldset> <inputs...> </fieldset> <span>"hotkey"</span> (at the minimum)
			//-----------------------------------------------------------------ALL INPUT TYPES
			input.parents = htmlParent.id;						  //Each json object gets a string list of its parents
			var labelObj = document.createElement("label"); 	  //The LABEL is what actually names each input field
			labelObj.innerHTML = input.name + ":"; 				  //Set LABEL name to be based on the provided json name
			//htmlParent.appendChild(labelObj); 					  //Add LABEL to given parent
			var fieldsetObj = document.createElement("fieldset"); //This FIELDSET contains all the parts of the html INPUTS associated with this json input
			fieldsetObj.append(labelObj);
			htmlParent.appendChild(fieldsetObj); 				  //Add FIELDSET to PARENT
			fieldsetObj.id = htmlParent.id + "." + input.name;	  //The FIELDSET becomes named based on parent
			input.id = fieldsetObj.id;							  //Allows the json input to be easily correlated to it's FIELDSET counterpart by the json .id attribute
			if (input.required == false)						  //Change the rendering class if this fieldset isnt required
			{
				labelObj.className = "optional-field";		  	  //Allows special styling to be applied
			}
			
			switch (input.type)
			{
				case "number":	//---------------------------------------------------------NUMBER TYPE
					var inputObj = document.createElement("input"); 			//Creating a new INPUT html object
					fieldsetObj.appendChild(inputObj); 							//Add this number INPUT to the PARENT
					inputObj.className = "form";								//Configures CSS to display this input correctly.
					inputObj.required = input.required;							//Set this INPUT to required only if it's json data says so
					fieldsetObj.collect = function() 							//Defines the data collection function for number
					{
						if (this.children[1].name == "fraction")				//If the input is a fraction
						{
							console.log("Fraction value: " + ((Math.round((this.children[1].value/this.children[2].value)*1000))/1000))
							return ((Math.round((this.children[1].value/this.children[2].value)*1000))/1000) //return the next number divided by the number after that one
						}
						else
						{
							return this.children[1].value; 							//Returns the sole input. Number FIELDSETS have only one INPUT, a number INPUT
						}
					};
					fieldsetObj.hotSelect = function()																//Calls when the respective hotkey is pushed
					{
						document.getElementById(this.parentNode.id + ".Button").click();							//Simulates clicking on it's tab
						this.children[1].focus();																	//Focus on the only child element
						console.log(this.id + " valid?: " + this.check());				//DELETE ME
					};
					fieldsetObj.check = function()																	//Returns true if the associated fieldset is properly filled out
					{
						if (this.children[1].required == true || this.children[1].name == "fraction")														//If this field MUST be filled out
						{
							if (this.children[1].name == "fraction")
							{
								return (this.children[2].value != 0);
							}
							else
							{
								return (this.children[1].value != "");													//The data must be not blank
							}
						}
						else
						{
							return true;
						}
					};
					inputObj.min = input.details.min; 							//Create a minimum value property based on the json data
					console.log("data min: " + inputObj.min); //DELETE ME
					inputObj.max = input.details.max; 							//Create a maximum value property based on the json data
					inputObj.step = input.details.step; 						//Create a step property based on the json data
					inputObj.value = input.value; 								//Create a starting value property based on the json data
					if (input.details.slider == true) 							//If the number INPUT is supposed to be a slider:
					{
						inputObj.type = "range"; 							 //Change the INPUT type to range
						inputObj.name = "range";
						var sliderValueObj = document.createElement("span"); //This new SPAN object will display the current value of the slider in it
						fieldsetObj.appendChild(sliderValueObj); 			 //Add the new SPAN to the PARENT
						sliderValueObj.innerHTML = input.value; 			 //The initial SPAN interior number is the json input default value
						inputObj.oninput = function() 						 //Whenever the INPUT slider changes, updated the SPAN that shows the value
						{
							this.nextElementSibling.innerHTML = this.value;  //The value of the SPAN text becomes equal to the value of the SLIDER whenever the SLIDER becomes updated
						}
					}
					else if (input.details.fraction == true)
					{
						inputObj.type = "number";							 //Since fraction will be returned as a decimal type is still a number
						inputObj.name = "fraction";							 //Set fractions and ranges separate from numbers for number collection
						var denomInputObj = document.createElement("input"); //Create a second input field for the denominator of the fraction
						var fractionSymbol = document.createTextNode(" / "); //Create a variable containing the divisor symbol
						fieldsetObj.appendChild(fractionSymbol);			 //Insert divisor symbol into the html body
						fieldsetObj.appendChild(denomInputObj);				 //Add second input to the fieldset Object
					}
					else							//If the number INPUT is not slated to be a slider:
					{
						inputObj.type = "number";	//Explicitly defined the INPUT type as number
						inputObj.name = "number";
					}
					if (input.hotkey != null && input.hotkey != "")		//Now, regardless of the number INPUT type, a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span");  //The new SPAN object contains the hotkey assigned to this INPUT
						fieldsetObj.appendChild(hotkeyObj);				 //Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					 //Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				 //Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "text": //--------------------------------------------------------TEXT TYPE
					fieldsetObj.collect = function()	 //Defines the data collection function for text
					{
						return this.children[1].value;   //Returns the sole input. Text FIELDSETS have only one INPUT, a text INPUT
					};
					fieldsetObj.hotSelect = function()										//Calls when the respective hotkey is pushed
					{
						document.getElementById(this.parentNode.id + ".Button").click();	//Simulates clicking on it's tab
						this.children[1].focus();											//Focus on the only child element
						console.log(this.id + " valid?: " + this.check());	//DELETE ME
					};
					fieldsetObj.check = function()																	//Returns true if the associated fieldset is properly filled out
					{
						if (this.children[1].required == true)														//If this field MUST be filled out
						{
							return (this.children[1].value != "");													//The data must be not blank
						}
						else
						{
							return true; 																			//Otherwise, return all clear (true)
						}
					};
					if (input.details.paragraph != true) //If the input was defined as a paragraph, the text INPUT is made very large (i.e. textarea type)
					{
						var inputObj = document.createElement("input");    //Create the input as a text INPUT if not a paragraph
						inputObj.type = "text";							   //If non-paragraph, type must be explicitly defined
						inputObj.value = input.value; 					   //Assign default value to INPUT/TEXTAREA
						inputObj.placeholder = input.value; 			   //Assign default placeholder to INPUT/TEXTAREA
						inputObj.required = input.required;					//Set this INPUT to required only if it's json data says so
					}
					else												   //If it IS a paragraph type
					{
						var inputObj = document.createElement("textarea"); //Create the input as a TEXTAREA if it is a paragraph
						inputObj.value = input.value; 					   //Assign default value to INPUT/TEXTAREA
						inputObj.placeholder = input.value; 			   //Assign default placeholder to INPUT/TEXTAREA
						inputObj.required = input.required;				   //Set this INPUT to required only if it's json data says so	
					}
					fieldsetObj.appendChild(inputObj); 					   //Add the INPUT/TEXTAREA to the FIELDSET
					inputObj.className = "form";						   //Configures CSS to display this input correctly.
					if (input.hotkey != null && input.hotkey != "")		   //Now, regardless of being an INPUT or TEXTAREA, a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); 	//The new SPAN object contains the hotkey assigned to this INPUT/TEXTAREA
						fieldsetObj.appendChild(hotkeyObj);					//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";						//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;					//Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "checkbox": //---------------------------------------------------------------------------CHECKBOX TYPE
					fieldsetObj.collect = function()									   	//Defines the data collection function for a checkbox
					{
						return this.children[1].checked.toString();							//Return the boolean checked/not value of the checkbox
					};
					fieldsetObj.hotSelect = function()									   	//Calls when the respective hotkey is pushed
					{
						document.getElementById(this.parentNode.id + ".Button").click();	//Simulates clicking on it's tab
						this.children[1].focus();
						this.children[1].checked = !this.children[0].checked;				//Toggle the checkbox
						console.log(this.id + " valid?: " + this.check());	//DELETE ME
					};
					fieldsetObj.check = function()											//Returns true if the associated fieldset is properly filled out
					{
						return true;														//Checkboxes are always true or false. There is no way to tell if people have left it off or chosen false
					};
					var inputObj = document.createElement("input"); 						//Create new INPUT
					fieldsetObj.appendChild(inputObj); 										//Add INPUT to the FIELDSET
					inputObj.type = "checkbox"; 											//Make the INPUT type checkbox
					inputObj.className = "form";						   					//Configures CSS to display this input correctly.
					inputObj.checked = input.value;											//If the input json value field is true, then the box is checked by default
					inputObj.required = input.required;										//Required if json says it is
					if (input.hotkey != null && input.hotkey != "")							//Now a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); //The new SPAN object contains the hotkey assigned to this set of INPUTS
						fieldsetObj.appendChild(hotkeyObj);				//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				//Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "radio": //---------------------------------------------------------------------------RADIO TYPE
					fieldsetObj.collect = function()									   		//Defines the data collection function for a radio. Very similar to checkbox's
					{
						//---															   		//A radio's (json) FIELDSET contains multiple checkbox INPUTS
						var collectedValue = ""; 										   		//This string will accumulate the names of all the checked INPUTS
						for (var i = 0; i < this.children.length; i++)  				   		//Iterate through the FIELDSET children (a series of INPUTS)**
						{																   		//**Since the length is one indexed while the array is zero indexed THE VARIABLE IS COMPARED TO LESS THAN, NOT EQUAL TO**
							if (this.children[i].type == "radio") 					   	   		//Not every element in this FIELDSET is an INPUT. We much make sure we are only examining elements that area radio INPUTS
							{
								if (this.children[i].checked == true) 					   		//Check if the radio INPUT is checked
								{
									collectedValue = collectedValue + this.children[i].value + ", "; //If it is, add its value (name) to the accumulated value
								}
							}
						}
						return collectedValue.substring(0, collectedValue.length - 2); 	   		//Eliminates the ", " from the very end of the accumulation variable
					};
					fieldsetObj.hotSelect = function()											//Calls when the respective hotkey is pushed
					{
						document.getElementById(this.parentNode.id + ".Button").click();		//Simulates clicking on it's tab
						this.children[1].focus();												//Focus on the only child element
						console.log(this.id + " valid?: " + this.check());	//DELETE ME
					};
					fieldsetObj.check = function()												//Returns true if the associated fieldset is properly filled out
					{
						var atLeastOne = false;													//This is TRUE if at least one of the radios is checked
						if (this.children[1].required == true)									//If this field MUST be filled out
						{
							for (var i = 0; i < this.children.length; i++)  				   	//Iterate through the FIELDSET children (a series of INPUTS)**
							{																   		
								if (this.children[i].type == "radio") 					   	   	//Not every element in this FIELDSET is an INPUT. We much make sure we are only examining elements that area radio INPUTS
								{
									if (this.children[i].checked == true) 					   	//Check if the radio INPUT is checked
									{
										atLeastOne = true; 										//If it is, add its value (name) to the accumulated value
									}
								}
							}
							return atLeastOne;													//This radio field is valid if at least one of the radios was checked
						}
						else
						{
							return true; 															//Otherwise, return all clear (true)
						}
					};
					for (var h = 0; h < input.details.options.length; h++)		//A radio FIELDSET is composed of multiple checkbox-type INPUTS**
					{															//**Since the length is one indexed while the array is zero indexed THE VARIABLE IS COMPARED TO LESS THAN, NOT EQUAL TO**
						var tempInputObj = document.createElement("input"); 	//Create INPUT element
						fieldsetObj.appendChild(tempInputObj); 					//Add INPUT to FIELDSET
						tempInputObj.value = input.details.options[h];			//Name the value of the radio to be one of the options
						tempInputObj.type = "radio"; 							//Set INPUT to type radio
						tempInputObj.name = input.name; 						//All radio INPUTS in this FIELDSET must have the same name to work properly
						tempInputObj.className = "form";						//Configures CSS to display this input correctly
						tempInputObj.required = input.required;					//Each input is "required" if the json says this radio set is
						if (input.value == "") 									//If no default value is given:
						{
							tempInputObj.checked = false;  						//Then this radio INPUT is unchecked
						}
						else
						{
							tempInputObj.checked = input.value.includes(input.details.options[h]); 	//Else check through each of the input options and see if it matches the selected default input value
						}
						var tempSpanObj = document.createElement("span");		//Create a SPAN to label this checkbox INPUT
						fieldsetObj.appendChild(tempSpanObj);					//Add that SPAN to the fieldset
						tempSpanObj.innerHTML = "  " + input.details.options[h] + "  ";		//Set the SPAN to contain the proper label for this INPUT
					}
					if (input.hotkey != null && input.hotkey != "")		//Now a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); //The new SPAN object contains the hotkey assigned to this set of INPUTS
						fieldsetObj.appendChild(hotkeyObj);				//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";					//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;				//Display the json-defined hotkey inside of this SPAN
					}
				break;
				case "file": //-----------------------------------------------FILE TYPE
					var inputObj = document.createElement("input");		//Create INPUT object
					fieldsetObj.append(inputObj);						//Add INPUT object to FIELDSET
					inputObj.type = "file";								//Set INPUT type to file
					inputObj.name = input.name;							//Set INPUT name to the json input
					inputObj.required = input.required;					//Required if the json says it should be
					fieldsetObj.collect = function()					//Defines data collection function for a file
					{
						var fr = new FileReader();						//Used to convert the submitted image into text
						var result;										//Will be assigned to the result of conversion to text
						var isLoaded = false;							//This variable becomes true when our dreams do
						fr.onload = function()							//This function will execute once the image has successfully been converted
						{
							result = fr.result;							//Assign the successful reading to the return value
							console.log(result);						//Return read value
						}
						if (this.children[1].value != null) 			//If a file was actually submitted:
						{
							fr.readAsDataURL(this.children[1].files[0]);//Read that file as a image
						}
						else
						{
							result = "No Image";										//Otherwise, simply put 'no image' where the image string would go
						}
						return result; 													//Then, return the image
					};
					fieldsetObj.hotSelect = function()									//Calls when the respective hotkey is pushed
					{
						document.getElementById(this.parentNode.id + ".Button").click();//Simulates clicking on it's tab
						this.children[1].focus();										//Focus on the only child element
						this.children[1].click();										//Opens the file submit dialog
					};
					fieldsetObj.check = function()										//Returns true if the associated fieldset is properly filled out
					{
						if (this.children[1].required == true)							//If this field MUST be filled out
						{
							return (this.children[1].files[0] != null);					//The data must be not blank
						}
						else
						{
							return true; 												//Otherwise, return all clear (true)
						}
					};
					if (input.hotkey != null && input.hotkey != "")						//Now a hotkey element needs to be created
					{
						var hotkeyObj = document.createElement("span"); 				//The new SPAN object contains the hotkey assigned to this set of INPUTS
						fieldsetObj.appendChild(hotkeyObj);								//Add the new SPAN onto the PARENT
						hotkeyObj.className = "hotkey";									//Set the class for CSS
						hotkeyObj.innerHTML = input.hotkey;								//Display the json-defined hotkey inside of this SPAN
					}
				break;
			}
			//----------------------------ALL INPUT TYPES (AGAIN)
			fieldsetList.push(fieldsetObj); 									   //Append the FIELDSET onto a cumulative list
			inputList.push(input); 												   //Append the json input onto a cumulative list
		}

		//This function breaks down the input json file into smaller levels until it identifies the inputs. It renders each level as it goes. This is where the program really begins
		function renderLevel(htmlParent, level)
		{
			//----------------------------------------------------------------------TAB BUTTON CONTAINER
			var buttonContainerObj = document.createElement("div");		//Create a div that contains the tab buttons for this level
			htmlParent.appendChild(buttonContainerObj);					//Append to parent
			buttonContainerObj.className = "tabContainer";				//CSS
			for (var i = 0; i < level.length; i++) 						//For each element in the initial json array**
			{															//**Since the length is one indexed while the array is zero indexed THE VARIABLE IS COMPARED TO LESS THAN, NOT EQUAL TO**
				console.log("Creating object for: " + level[i].name)
				//----------------------------------------------------------------TAB BUTTON
				tabButtonObj = document.createElement("button");		//BUTTON that switches to this tab
				buttonContainerObj.appendChild(tabButtonObj);			//Attach this BUTTON to it's parent
				tabButtonObj.id = htmlParent.id + "." + level[i].name + ".Button";
				tabButtonObj.classList.add("tablinks");					//Styling for tab selection BUTTONS
				tabButtonObj.innerHTML = level[i].name + " Form";		//BUTTON text is the tab name
				tabButtonObj.onclick = function()						//When you click on a tab's selection button
				{
					var siblingTabs = this.parentNode.parentNode.children;				//
					for (var g = 0; g < siblingTabs.length; g++)						//For each element on this level (sibling)
					{
						if (siblingTabs[g].nodeName.toLowerCase() == "div" && siblingTabs[g].classList.contains("tabContent")) //If that element is a DIV and classContent (not a button container)
						{
							if (siblingTabs[g].id == this.id.replace(/.Button/, ""))	//For every fellow DIV on this level... (but not the current element) - works by taking the button ID and chopping the ".Button" part off to find it's respective tab
							{
								siblingTabs[g].style.display = "block";					//Show DIV
							}
							else
							{
								siblingTabs[g].style.display = "none";					//Hide that DIV
							}
						}
					}
					for (var k = 0; k < this.parentNode.children.length; k++) 			//Iterates through fellow tab buttons
					{
						this.parentNode.children[k].classList.remove("tab-selected");	//Remove tab-selected from all fellow buttons
					}
					this.classList.add("tab-selected"); 								//Add tab-selected back to the clicked button
				}
				//----------------------------------------------------------------------TAB DIV CREATION
				var currentObj = document.createElement("div");			//Create a DIV
				htmlParent.appendChild(currentObj);						//Attach this DIV to either a parent DIV or the top-level document
				currentObj.classList.add("tabContent");					//Make this division look like a tab
				if (i == 0) 											//If this is the first tab in this level
				{
					currentObj.style.display = "block";					//Make it visible
					tabButtonObj.classList.add("tab-selected");				//Styling for tab selection BUTTONS
				}	
				else													//Otherwise
				{
					currentObj.style.display = "none";					//Hide it
				}
				currentObj.id = htmlParent.id + "." + level[i].name;	//Assign an id to the DIV based on its PARENT name as well
				level[i].id = currentObj.id;							//Save the id of this div to the json
				if (level[i].terminal == false) 						//If this json level is not marked as "terminal"
				{
					console.log("-" + level[i].name + " is not terminating.");
					renderLevel(currentObj, level[i].tabs); 			//Recursively call this function to process the next array level
				}
				else 													//If this json level is terminal, it is an "input"
				{
					console.log("-" + level[i].name + " is terminating.");
					for (var j = 0; j < level[i].inputs.length; j++)	//For each "input" in this level
					{
						renderInput(currentObj, level[i].inputs[j]);	//Call render input, which will append "html input elements" (sorta) onto the "currentObj" element
					}
				}
				//---------------------------------------------------------------------------BUTTON CREATION
				if (level[i].submittable == true) 						//After rendering all subinputs, create a button if this level is submittable.
				{
					//---												//When the button is pressed, the data from all the subelements with be collected
					var buttonObj = document.createElement("button");	//Create BUTTON html object
					currentObj.appendChild(buttonObj);					//Add the BUTTON as a subelement of whatever DIV we currently edit
					buttonObj.innerHTML = "Submit " + level[i].name;	//Give the BUTTON a name based on json
					buttonObj.className = "form-submit";				//Mark the BUTTON for proper css
					buttonObj.onclick = function()						//Executes on click
					{
						var parentName = this.parentElement.id.slice(this.parentElement.id.lastIndexOf("."), this.parentElement.id.length); //The directly-parent level name. See below for explanation
						//parentElement.id = ".Match.Main" (as example)
						//.lastIndexOf - grabs the index of the last occurence of "." = 13
						//.length = 17
						//.slice(13, 17) = "Main"
						//"Main" is the id of the element that DIRECTLY contains this one
						writeData(parentName); 																							  		//On click, gather all data inside this section
						//console.log("Current state of the json inputs: " + JSON.stringify(inputList)); 										    //TEMP
					}
				}
			}
		}
		
		//Converts a given number to it's ASCII letter
		function toASCII(number)
		{
			switch (number)
			{
				case 192:
					return "`";
				break;
				case 16:
					return "SHIFT"
				break;
				case 189:
					return "-";
				break;
				case 187:
					return "+";
				break;
				case 18:
					return "[";
				case 17:
					return "CONTROL"
				break;
				case 186:
					return ";";
				break;
				case 222:
					return "\"";
				break;
				case 188:
					return ",";
				break;
				case 190:
					return ".";
				break;
				case 191:
					return "/";
				break;
				case 220:
					return "\\";
				break;
				default:
					return String.fromCharCode(number);					    				//Returns ascii character	
				break;
			}
		}
		
		//Triggers on hotkey presses. Calls the proper switch function for the press
		function hotkeyManager(e)
		{
			if (e.keyCode == 18)																//If alt was pressed
			{
				e.preventDefault();																//Stops all chrome hotkeys
				altPressed = true;																//Turn on altPressed until release event
			}
			else																				//If we didn't press alt (Alt isnt allowed as a hotkey)
			{
				for (var y = 0; y < inputList.length; y++)							 			//Iterate through all json inputs
				{
					if (inputList[y].hotkey.toUpperCase() == toASCII(e.keyCode).toUpperCase())	//If the hotkey matches the pressed key
					{
						if (altPressed == true)													//Alt must be held
						{
							e.preventDefault();
							document.getElementById(inputList[y].id).hotSelect();				//Activate the function for it's corresponding fieldset that brings that fieldset into view		
						}
					}
				}	
			}
		}
		
		//Triggers on alt-release
		function altUpManager(e)
		{
			e.preventDefault();					//Stops all chrome hotkeys
			if (e.keyCode == 18)				//If the released key was alt
			{
				altPressed = false;				//Set altPressed to false
			}
		}

		//---GLOBAL VARIABLES---
		var inputList = []; 	//Contains all inputs found within the configuration file
		var fieldsetList = [];  //Contains all the fieldsets of inputs
		var altPressed = false; //True when the ALT key is pressed

		var configFile = [
			{
				"name":"Match",
				"submittable":true,
				"terminal":false,
				"tabs":
				[
					{
						"name":"Main",
						"submittable":false,
						"terminal":true,
						"inputs":
						[
							{
								"name":"Match Number",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"`",
								"details":
								{
									"min":1,
									"max":9999,
									"step":1,
									"slider":false,
									"fraction":false
								}
							},
							{
								"name":"Team Number",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"1",
								"details":
								{
									"min":1,
									"max":9999,
									"step":1,
									"slider":false,
									"fraction":false
								}
							},
							{
								"name":"Team Name",
								"type":"text",
								"value":"",
								"required":false,
								"hotkey":"2",
								"details":
								{
									"paragraph":false
								}
							}
						]
					},
					{
						"name":"Auto",
						"submittable":false,
						"terminal":true,
						"inputs":
						[
							{
								"name":"Crosses Baseline Successfully",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"4",
								"details":
								{}
							},
							{
								"name":"Cubes Put In Switch (Successes/Attempts)",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"5",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Cubes Put In Scale (Successes/Attempts)",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"Q",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Cubes Put In Vault/Exchange Zone (Successes/Attempts)",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"W",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Comments/Overview",
								"type":"text",
								"value":"",
								"required":false,
								"hotkey":"E",
								"details":
								{
									"paragraph":true
								}
							}
						]
					},
					{
						"name":"Teleop",
						"submittable":false,
						"terminal":true,
						"inputs":
						[
							{
								"name":"Cubes Put In Switch (Successes/Attempts)",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"R",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Cubes Put In Scale (Successes/Attempts)",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"A",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Cubes Put In Vault/Exchange Zone (Successes/Attempts)",
								"type":"number",
								"value":"",
								"required":true,
								"hotkey":"G",
								"details":
								{
									"min":0,
									"max":999,
									"step":1,
									"slider":false,
									"fraction":true
								}
							},
							{
								"name":"Primary Source of Cubes",
								"type":"radio",
								"value":"",
								"required":true,
								"hotkey":"D",
								"details":
								{
									"options":["Allied Platform", "Enemy Platform", "Portal", "Power Cube Zone"]
								}
							},
							{
								"name":"Attempts to Block Enemy Scoring",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"F",
								"details":
								{}
							},
							{
								"name":"Lifts Successfully",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"Z",
								"details":
								{}
							},
							{
								"name":"Another Robot Hangs Off of This One",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"X",
								"details":
								{}
							},
							{
								"name":"Attempts to Put Cubes on Switch",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"C",
								"details":
								{}
							},
							{
								"name":"Attempts to Put Cubes on Scale",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"B",
								"details":
								{}
							},
							{
								"name":"Attempts to Provide Cubes to Vault",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"H",
								"details":
								{}
							},
							{
								"name":"Can Finish on Platform",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"H",
								"details":
									{}
							},
							{
								"name":"Attempts to Lift",
								"type":"checkbox",
								"value":"",
								"required":false,
								"hotkey":"N",
								"details":
								{}
							},
							{
								"name":"Comments/Overview",
								"type":"text",
								"value":"",
								"required":false,
								"hotkey":"V",
								"details":
								{
									"paragraph":true
								}
							}
						]
					}
				]
			},
			{
				"name":"Pit",
				"terminal":true,
				"submittable":true,
				"inputs":
				[
					{
						"name":"Robot Image",
						"type":"file",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{
							"formats":[".png",".jpg"]
						}
					},
					{
						"name":"Team Number",
						"type":"number",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"min":1,
							"max":9999,
							"step":1,
							"slider":false,
							"fraction":false
						}
					},
					{
						"name":"Team Name",
						"type":"text",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{
							"paragraph":false
						}
					},
					{
						"name":"Type of Motors on Drivetrain",
						"type":"text",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"paragraph":false
						}
					},
					{
						"name":"Number of Motors on Drive",
						"type":"text",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"paragraph":false
						}
					},
					{
						"name":"Drivetrain Overview/Comments",
						"type":"text",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{
							"paragraph":false
						}
					},
					{
						"name":"Can Lift",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{}
					},
					{
						"name":"Lift Clearance from Ground",
						"type":"number",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"min":1,
							"max":120,
							"step":0.5,
							"slider":false,
							"fraction":false
						}
					},
					{
						"name":"Weight",
						"type":"number",
						"value":120,
						"required":true,
						"hotkey":"",
						"details":
						{
							"min":1,
							"max":120,
							"step":1,
							"slider":true,
							"fraction":false
						}
					},
					{
						"name":"Automatically Adjusts Side on Autonomous",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{}
					},
					{
						"name":"Puts Cube on Switch in Autonomous",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{}
					},
					{
						"name":"Puts Cube on Scale in Autonomous",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{}
					},
					{
						"name":"Main Strategy: Put Cubes on Switch?",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{}
					},
					{
						"name":"Main Strategy: Put Cubes on Scale?",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{}
					},
					{
						"name":"Main Strategy: Provide Cubes to Vault?",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{}
					},
					{
						"name":"Main Strategy: Lift Reliably?",
						"type":"checkbox",
						"value":"",
						"required":false,
						"hotkey":"",
						"details":
						{}
					},
					{
						"name":"Primary Source of Cubes",
						"type":"radio",
						"value":"",
						"required":true,
						"hotkey":"",
						"details":
						{
							"options":["Allied Platform", "Enemy Platform", "Portal", "Power Cube Zone"]
						}
					}
				]
			}	
		]

		//---ONLOAD FUNCTION CALLS---
		document.addEventListener("keydown", hotkeyManager, false); //Registers hotkeyManager as an event listener
		document.addEventListener("keyup", altUpManager, false);	//Registers altUpManager as a listener
		renderLevel(document.body, configFile); 					//Renders the configuration object above, using the document body as the parent. Kicks off the program.
	</script>
</html>
